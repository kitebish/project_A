---
description: React best practices and patterns for functional components
globs:
  - "**/*.jsx"
  - "**/*.tsx"
  - "**/components/**"
alwaysApply: false
---

# React Rules

Applied when working with React components (.jsx, .tsx files).

## Component Structure

### Use Functional Components
- Always use functional components with hooks
- Never use class components for new code
- Keep components small and focused

**Examples**:
```typescript
// ✓ Good: Functional component
interface UserCardProps {
  user: User;
  onEdit: (id: string) => void;
}

export const UserCard: React.FC<UserCardProps> = ({ user, onEdit }) => {
  return (
    <div className="user-card">
      <h3>{user.name}</h3>
      <button onClick={() => onEdit(user.id)}>Edit</button>
    </div>
  );
};
```

## Hooks

### Hook Rules
- Only call hooks at the top level
- Only call hooks from React functions
- Use custom hooks for reusable logic
- Follow naming convention: `use[Name]`

### Common Hooks

**useState**:
```typescript
// ✓ Good
const [count, setCount] = useState<number>(0);
const [user, setUser] = useState<User | null>(null);
```

**useEffect**:
```typescript
// ✓ Good: Proper dependencies
useEffect(() => {
  fetchUser(userId).then(setUser);
}, [userId]); // Dependency array

// ✓ Good: Cleanup
useEffect(() => {
  const timer = setInterval(() => {
    console.log('tick');
  }, 1000);
  
  return () => clearInterval(timer); // Cleanup
}, []);
```

**useCallback & useMemo**:
```typescript
// ✓ Good: Memoize expensive calculations
const expensiveValue = useMemo(() => {
  return computeExpensiveValue(data);
}, [data]);

// ✓ Good: Memoize callbacks passed to children
const handleClick = useCallback(() => {
  doSomething(id);
}, [id]);
```

## Custom Hooks

### Create Custom Hooks for Reusable Logic

**Examples**:
```typescript
// ✓ Good: Custom hook for API calls
function useUser(userId: string) {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    setLoading(true);
    fetchUser(userId)
      .then(setUser)
      .catch(setError)
      .finally(() => setLoading(false));
  }, [userId]);

  return { user, loading, error };
}

// Usage
function UserProfile({ userId }: { userId: string }) {
  const { user, loading, error } = useUser(userId);
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  if (!user) return <div>User not found</div>;
  
  return <div>{user.name}</div>;
}
```

## Props

### Props Best Practices
- Always define prop types with TypeScript interfaces
- Use destructuring in function parameters
- Provide default values when appropriate
- Keep props minimal (max 5-7 props)

**Examples**:
```typescript
// ✓ Good
interface ButtonProps {
  label: string;
  onClick: () => void;
  variant?: 'primary' | 'secondary';
  disabled?: boolean;
}

export const Button: React.FC<ButtonProps> = ({
  label,
  onClick,
  variant = 'primary',
  disabled = false,
}) => {
  return (
    <button
      className={`btn btn-${variant}`}
      onClick={onClick}
      disabled={disabled}
    >
      {label}
    </button>
  );
};
```

## State Management

### Local State
- Use `useState` for component-local state
- Lift state up when needed by multiple components
- Don't over-lift state

### Context API
- Use Context for global/shared state
- Create separate contexts for different concerns
- Provide type-safe context

**Examples**:
```typescript
// ✓ Good: Type-safe context
interface AuthContextType {
  user: User | null;
  login: (email: string, password: string) => Promise<void>;
  logout: () => void;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);

  const login = async (email: string, password: string) => {
    const user = await api.login(email, password);
    setUser(user);
  };

  const logout = () => setUser(null);

  return (
    <AuthContext.Provider value={{ user, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
};
```

## Component Organization

### File Structure
```
components/
├── UserCard/
│   ├── UserCard.tsx          ← Main component
│   ├── UserCard.test.tsx     ← Tests
│   ├── UserCard.module.css   ← Styles
│   └── index.ts              ← Re-export
```

### Component Anatomy
```typescript
// 1. Imports
import React, { useState, useEffect } from 'react';
import { User } from '@/types';
import styles from './UserCard.module.css';

// 2. Types
interface UserCardProps {
  userId: string;
}

// 3. Component
export const UserCard: React.FC<UserCardProps> = ({ userId }) => {
  // 3a. Hooks
  const [user, setUser] = useState<User | null>(null);
  
  useEffect(() => {
    fetchUser(userId).then(setUser);
  }, [userId]);

  // 3b. Event handlers
  const handleEdit = () => {
    console.log('Edit user:', userId);
  };

  // 3c. Render helpers
  if (!user) return <div>Loading...</div>;

  // 3d. JSX
  return (
    <div className={styles.card}>
      <h3>{user.name}</h3>
      <button onClick={handleEdit}>Edit</button>
    </div>
  );
};
```

## Performance

### Avoid Unnecessary Re-renders
- Use `React.memo` for expensive components
- Use `useCallback` for callbacks passed to memoized children
- Use `useMemo` for expensive calculations

**Examples**:
```typescript
// ✓ Good: Memoized component
export const UserList = React.memo<UserListProps>(({ users, onUserClick }) => {
  return (
    <ul>
      {users.map(user => (
        <UserCard key={user.id} user={user} onClick={onUserClick} />
      ))}
    </ul>
  );
});
```

## Conditional Rendering

### Best Practices
- Use ternary for simple conditions
- Use `&&` for conditional rendering
- Extract complex conditions to variables

**Examples**:
```typescript
// ✓ Good: Simple ternary
{isLoading ? <Spinner /> : <Content />}

// ✓ Good: Conditional with &&
{error && <ErrorMessage error={error} />}

// ✓ Good: Complex condition extracted
const showWelcome = isLoggedIn && !hasSeenWelcome && isFirstVisit;
{showWelcome && <WelcomeModal />}
```

## Lists and Keys

### Always Use Keys
- Use unique, stable keys (preferably IDs)
- Never use array index as key (unless list is static)
- Keys must be unique among siblings

**Examples**:
```typescript
// ✓ Good: Using ID as key
{users.map(user => (
  <UserCard key={user.id} user={user} />
))}
```

## Forms

### Controlled Components
- Use controlled components for forms
- Handle form submission properly
- Validate input

**Examples**:
```typescript
function LoginForm() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    login(email, password);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
        required
      />
      <input
        type="password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
        required
      />
      <button type="submit">Login</button>
    </form>
  );
}
```

## Styling

### CSS Modules (Preferred)
```typescript
import styles from './Button.module.css';

export const Button = () => (
  <button className={styles.primary}>Click me</button>
);
```

### Conditional Classes
```typescript
import classNames from 'classnames';

<button
  className={classNames(styles.button, {
    [styles.active]: isActive,
    [styles.disabled]: isDisabled,
  })}
>
  Click me
</button>
```
